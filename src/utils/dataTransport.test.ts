import { describe, it, expect } from 'vitest'
import { generateExportUrl, parseImportUrl, parseFileContent } from './dataTransport'
import type { ExpenseRecord, User } from '../types'

// Sample test data
const sampleUser: User = {
  email: 'test@example.com',
  alias: 'Test User',
}

const sampleRecord: ExpenseRecord = {
  uuid: '123e4567-e89b-12d3-a456-426614174000',
  title: 'Test Expense',
  description: 'Test description',
  category: 'Food',
  amount: 100,
  currency: 'INR',
  date: '2024-01-15',
  time: '12:00',
  icon: 'ðŸ”',
  paidBy: [{ email: 'test@example.com', share: 100 }],
  paidFor: [{ email: 'test@example.com', share: 100 }],
  shareType: 'equal',
  groupId: 'default-group',
  comments: '',
  createdAt: 1705312800000,
  updatedAt: 1705312800000,
}

describe('generateExportUrl', () => {
  it('should generate a valid URL for small payloads', () => {
    const result = generateExportUrl([sampleRecord], [sampleUser], 'https://example.com')

    expect(result.success).toBe(true)
    if (result.success) {
      expect(result.url).toContain('https://example.com/import?data=')
      expect(result.url.length).toBeLessThanOrEqual(2000)
    }
  })

  it('should generate URL-safe base64 (no +, /, or = characters in data)', () => {
    const result = generateExportUrl([sampleRecord], [sampleUser], 'https://example.com')

    expect(result.success).toBe(true)
    if (result.success) {
      const dataParam = result.url.split('data=')[1]
      expect(dataParam).not.toContain('+')
      expect(dataParam).not.toContain('/')
      expect(dataParam).not.toContain('=')
    }
  })

  it('should fail for payloads exceeding URL length limit', () => {
    // Create many records to exceed 2000 char limit
    const manyRecords = Array(50)
      .fill(null)
      .map((_, i) => ({
        ...sampleRecord,
        uuid: `uuid-${i}`,
        title: `Record ${i} with a longer title to increase size`,
      }))

    const result = generateExportUrl(manyRecords, [sampleUser], 'https://example.com')

    expect(result.success).toBe(false)
    if (!result.success) {
      expect(result.error).toContain('URL too long')
    }
  })

  it('should handle unicode characters in record data', () => {
    const unicodeRecord: ExpenseRecord = {
      ...sampleRecord,
      title: 'Dinner at æ—¥æœ¬æ–™ç†åº—',
      description: 'Great sushi! ðŸ£',
    }

    const result = generateExportUrl([unicodeRecord], [sampleUser], 'https://example.com')

    expect(result.success).toBe(true)
  })
})

describe('parseImportUrl', () => {
  it('should parse a URL generated by generateExportUrl', () => {
    const exportResult = generateExportUrl([sampleRecord], [sampleUser], 'https://example.com')

    expect(exportResult.success).toBe(true)
    if (!exportResult.success) return

    const parseResult = parseImportUrl(exportResult.url)

    expect(parseResult.success).toBe(true)
    if (parseResult.success) {
      expect(parseResult.payload.version).toBe(1)
      expect(parseResult.payload.records).toHaveLength(1)
      expect(parseResult.payload.records[0].uuid).toBe(sampleRecord.uuid)
      expect(parseResult.payload.users).toHaveLength(1)
      expect(parseResult.payload.users[0].email).toBe(sampleUser.email)
    }
  })

  it('should parse just the data parameter without full URL', () => {
    const exportResult = generateExportUrl([sampleRecord], [sampleUser], 'https://example.com')

    expect(exportResult.success).toBe(true)
    if (!exportResult.success) return

    const dataParam = exportResult.url.split('data=')[1]
    const parseResult = parseImportUrl(dataParam)

    expect(parseResult.success).toBe(true)
  })

  it('should handle unicode characters correctly', () => {
    const unicodeRecord: ExpenseRecord = {
      ...sampleRecord,
      title: 'CafÃ© â˜• & BÃ¤ckerei ðŸ¥',
      description: 'æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆ',
    }

    const exportResult = generateExportUrl([unicodeRecord], [sampleUser], 'https://example.com')
    expect(exportResult.success).toBe(true)
    if (!exportResult.success) return

    const parseResult = parseImportUrl(exportResult.url)

    expect(parseResult.success).toBe(true)
    if (parseResult.success) {
      expect(parseResult.payload.records[0].title).toBe('CafÃ© â˜• & BÃ¤ckerei ðŸ¥')
      expect(parseResult.payload.records[0].description).toBe('æ—¥æœ¬èªžãƒ†ã‚¹ãƒˆ')
    }
  })

  it('should fail for invalid base64 data', () => {
    const result = parseImportUrl('https://example.com/import?data=invalid!!base64')

    expect(result.success).toBe(false)
  })

  it('should fail for missing data parameter', () => {
    const result = parseImportUrl('https://example.com/import?data=')

    expect(result.success).toBe(false)
    if (!result.success) {
      expect(result.error).toContain('No data found')
    }
  })

  it('should fail for invalid JSON payload', () => {
    // Valid base64 but not valid JSON
    const invalidJson = btoa('not json').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '')

    const result = parseImportUrl(`https://example.com/import?data=${invalidJson}`)

    expect(result.success).toBe(false)
  })

  it('should fail for wrong version', () => {
    const payload = { version: 2, records: [], users: [] }
    const encoded = btoa(JSON.stringify(payload))
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=+$/, '')

    const result = parseImportUrl(`https://example.com/import?data=${encoded}`)

    expect(result.success).toBe(false)
    if (!result.success) {
      expect(result.error).toContain('Unsupported version')
    }
  })
})

describe('parseFileContent', () => {
  it('should parse valid file content', () => {
    const fileContent = JSON.stringify({
      version: 1,
      exportedAt: Date.now(),
      records: [sampleRecord],
      users: [sampleUser],
    })

    const result = parseFileContent(fileContent)

    expect(result.success).toBe(true)
    if (result.success) {
      expect(result.payload.records).toHaveLength(1)
      expect(result.payload.users).toHaveLength(1)
    }
  })

  it('should parse file content with groups', () => {
    const fileContent = JSON.stringify({
      version: 1,
      exportedAt: Date.now(),
      records: [sampleRecord],
      users: [sampleUser],
      groups: [{ uuid: 'group-1', name: 'Test Group', members: ['test@example.com'] }],
    })

    const result = parseFileContent(fileContent)

    expect(result.success).toBe(true)
    if (result.success) {
      expect(result.payload.groups).toHaveLength(1)
    }
  })

  it('should fail for invalid JSON', () => {
    const result = parseFileContent('not valid json {')

    expect(result.success).toBe(false)
  })

  it('should fail for missing records array', () => {
    const result = parseFileContent(JSON.stringify({ version: 1, users: [] }))

    expect(result.success).toBe(false)
    if (!result.success) {
      expect(result.error).toContain('records is not an array')
    }
  })

  it('should fail for missing users array', () => {
    const result = parseFileContent(JSON.stringify({ version: 1, records: [] }))

    expect(result.success).toBe(false)
    if (!result.success) {
      expect(result.error).toContain('users is not an array')
    }
  })
})

describe('URL round-trip', () => {
  it('should preserve all record fields through export/import cycle', () => {
    const fullRecord: ExpenseRecord = {
      uuid: 'test-uuid-123',
      title: 'Complete Record',
      description: 'With all fields',
      category: 'Shopping',
      amount: 1234.56,
      currency: 'USD',
      date: '2024-06-15',
      time: '14:30',
      icon: 'ðŸ›’',
      paidBy: [
        { email: 'alice@example.com', share: 50 },
        { email: 'bob@example.com', share: 50 },
      ],
      paidFor: [
        { email: 'alice@example.com', share: 25 },
        { email: 'bob@example.com', share: 25 },
        { email: 'charlie@example.com', share: 50 },
      ],
      shareType: 'percentage',
      groupId: 'trip-group',
      comments: 'Split for the trip',
      sourceHash: 'bank:abc123',
      createdAt: 1718451000000,
      updatedAt: 1718451000000,
    }

    const users: User[] = [
      { email: 'alice@example.com', alias: 'Alice' },
      { email: 'bob@example.com', alias: 'Bob' },
      { email: 'charlie@example.com', alias: 'Charlie' },
    ]

    const exportResult = generateExportUrl([fullRecord], users, 'https://test.com')
    expect(exportResult.success).toBe(true)
    if (!exportResult.success) return

    const parseResult = parseImportUrl(exportResult.url)
    expect(parseResult.success).toBe(true)
    if (!parseResult.success) return

    const importedRecord = parseResult.payload.records[0]

    // Verify all fields are preserved
    expect(importedRecord.uuid).toBe(fullRecord.uuid)
    expect(importedRecord.title).toBe(fullRecord.title)
    expect(importedRecord.description).toBe(fullRecord.description)
    expect(importedRecord.category).toBe(fullRecord.category)
    expect(importedRecord.amount).toBe(fullRecord.amount)
    expect(importedRecord.currency).toBe(fullRecord.currency)
    expect(importedRecord.date).toBe(fullRecord.date)
    expect(importedRecord.time).toBe(fullRecord.time)
    expect(importedRecord.icon).toBe(fullRecord.icon)
    expect(importedRecord.paidBy).toEqual(fullRecord.paidBy)
    expect(importedRecord.paidFor).toEqual(fullRecord.paidFor)
    expect(importedRecord.shareType).toBe(fullRecord.shareType)
    expect(importedRecord.groupId).toBe(fullRecord.groupId)
    expect(importedRecord.comments).toBe(fullRecord.comments)
    expect(importedRecord.sourceHash).toBe(fullRecord.sourceHash)
    expect(importedRecord.createdAt).toBe(fullRecord.createdAt)
    expect(importedRecord.updatedAt).toBe(fullRecord.updatedAt)
  })
})
